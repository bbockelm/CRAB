/* soapCRAB_ProxySOAPService.h
   Generated by gSOAP 2.7.9l from CRAB-Proxy.h
   Copyright(C) 2000-2007, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#ifndef soapCRAB_ProxySOAPService_H
#define soapCRAB_ProxySOAPService_H

#include "soapH.h"

#include <Python.h>
#include <cstring>
#include <iostream>
#include <sstream>

class SOAP_CMAC CRAB_ProxySOAPService : public soap
{ 

public:
	/// Constructor
	CRAB_ProxySOAPService();
	/// Constructor with engine input+output mode control
	CRAB_ProxySOAPService(soap_mode iomode);
	/// Constructor with engine input and output mode control
	CRAB_ProxySOAPService(soap_mode imode, soap_mode omode);
	/// Destructor frees all data
	virtual ~CRAB_ProxySOAPService();
	/// Initializer used by constructor
	virtual	void CRAB_ProxySOAPService_init(soap_mode imode, soap_mode omode);
	/// Return a copy
	virtual	CRAB_ProxySOAPService *copy();
	/// Disables and removes SOAP Header from message
	virtual	void soap_noheader();
	/// Run simple single-thread iterative service on port until a connection error occurs (returns error code or SOAP_OK), use this->bind_flag = SO_REUSEADDR to rebind for a rerun
	virtual	int run(int port);
	/// Bind service to port (returns master socket or SOAP_INVALID_SOCKET)
	virtual	SOAP_SOCKET bind(const char *host, int port, int backlog);
	/// Accept next request (returns socket or SOAP_INVALID_SOCKET)
	virtual	SOAP_SOCKET accept();
	/// Serve this request (returns error code or SOAP_OK)
	virtual	int serve();
	/// Used by serve() to dispatch a request (returns error code or SOAP_OK)
	virtual	int dispatch();

	/// Service operations (you should define these):
	/// Web service operation 'transferTaskAndSubmit' (return error code or SOAP_OK)
	virtual	int transferTaskAndSubmit(ns1__transferTaskType *transferTaskAndSubmitRequest, struct ns1__transferTaskAndSubmitResponse &_param_1) 
	{
		// Parse input data
		char* taskDescriptor;
		char* cmdDescriptor;
		char* UUID;

		taskDescriptor = transferTaskAndSubmitRequest->taskDescriptor;
		cmdDescriptor = transferTaskAndSubmitRequest->cmdDescriptor;
		UUID = transferTaskAndSubmitRequest->uuid;

		// Summon python wrapper
	        PyObject *pResult;
        	int res;

                PyObject *td = PyString_FromString(taskDescriptor);
                PyObject *cd = PyString_FromString(cmdDescriptor);
                PyObject *ud = PyString_FromString(UUID);

                if ((td==NULL)or(cd==NULL)or(ud==NULL))
		{
                     PyErr_Print();
                     std::cout << "Error while parsing gway_transferTaskAndSubmit arguments" << std::endl;
                     res = -2;
		}

	        pResult = PyObject_CallMethod(pInstance, "gway_transferTaskAndSubmit", "(OOO)", td, cd, ud);

        	if (pResult == NULL)
	        {
			PyErr_Print();
                	std::cout << "Error while calling gway_transferTaskAndSubmit " << std::endl;
			res = -1;
        	} else {
	                res = PyInt_AsLong(pResult);
		}
		
		// parse back the response code to SOAP
		std::stringstream ss;
		ss << res;
		_param_1.transferTaskAndSubmitResponse = const_cast<char*>(ss.str().c_str());

	        Py_XDECREF(pResult);
		std::cout << "transferTaskAndSubmit RPC" << std::endl;
		return SOAP_OK;
	}

	/// Web service operation 'sendCommand' (return error code or SOAP_OK)
	virtual	int sendCommand(ns1__sendCommandType *sendCommandRequest, struct ns1__sendCommandResponse &_param_2) 
	{
		char* cmdDescriptor;
		char* UUID;

                cmdDescriptor = sendCommandRequest->cmdDescriptor;
                UUID = sendCommandRequest->uuid;

		// summon logic
	        PyObject *pResult;
        	int res;

	        pResult = PyObject_CallMethod(pInstance, "gway_sendCommand", "(ss)", cmdDescriptor, UUID);
        	if (pResult == NULL)
	        {
        	        PyErr_Print();
                	std::cout << "Error while calling gway_sendCommand " << std::endl;
	                res = -1;
        	} else {
			res = PyInt_AsLong(pResult);
		}

		// prepare response
                std::stringstream ss;
                ss << res;
		_param_2.sendCommandResponse = const_cast<char*>(ss.str().c_str());

	        Py_XDECREF(pResult);
                std::cout << "sendCommand RPC" << std::endl;
		return SOAP_OK;
	}

	/// Web service operation 'getTaskStatus' (return error code or SOAP_OK)
	virtual	int getTaskStatus(char *getTaskStatusRequest, struct ns1__getTaskStatusResponse &_param_3)
	{
		// extract data
		char* UUID;
		UUID = getTaskStatusRequest;

		// summon
	        PyObject *pResult;
		char* res;

        	pResult = PyObject_CallMethod(pInstance, "gway_getTaskStatus", "(s)", UUID);
	        if (pResult == NULL)
        	{
	                PyErr_Print();
        	        std::cout << "Error while calling gway_getTaskStatus " << std::endl;
                	res = "";
	        } else {
			res = PyString_AsString(pResult);
		}

		// constuct response
		_param_3.getTaskStatusResponse = res;	
		std::cout << "getTaskStatus RPC" << std::endl;
		return SOAP_OK;
	}

private:
	PyObject *pInstance;

protected:
	// summoned by constructor/destructor methods

	void initPy(void)
	{
	        PyObject *pModule, *pClass;
        	Py_Initialize();
                std::cout << "Initializing backend..." << std::endl;

	        pModule = PyImport_ImportModule("CRAB-CmdMgr-Backend");
        	if (pModule == NULL){
                	PyErr_Print();
	                Py_Finalize();
        	        std::cout << "Unable to load backend module. Check if it is in PYTHONPATH" << std::endl;
                	exit(-1);
	        }

	        pClass = PyObject_GetAttrString(pModule, "CRAB_AS_beckend" );
        	Py_DECREF(pModule);
	        if (pClass == NULL){
        	        PyErr_Print();
                	Py_Finalize();
	                std::cout << "Unable to get attributes for backend class" << std::endl;
        	        return;
	        }
        	if (PyCallable_Check(pClass)!=1){
                	PyErr_Print();
	                Py_Finalize();
        	        std::cout << "Backend class not callable" << std::endl;
               		return;
	        }

	        pInstance = PyObject_CallObject(pClass, Py_BuildValue("()"));
        	if (pInstance == NULL){
                	PyErr_Print();
	                Py_Finalize();
        	        std::cout << "Error while allocating backend" << std::endl;
                	return;
	        }

                std::cout << "Frontend and backend ready and waiting for RPCs..." << std::endl;
        	Py_DECREF(pClass);
	}

	void finalizePy()
	{
        	Py_XDECREF(pInstance);
	        Py_Finalize();
	}

};
#endif



